package replicatedtodo

import (
	"bytes"
	"fmt"
)

type errorString string

func (e errorString) Error() string { return string(e) }

const (
	alphabetLow  = 'a'
	alphabetHigh = 'z'

	alphabetPred = alphabetLow - 1
	alphabetSucc = alphabetHigh + 1

	ErrInvalidArgument = errorString("invalid argument")
)

type OrderString []byte

func validByte(b byte) bool {
	return b >= alphabetLow && b <= alphabetHigh
}

func (s OrderString) Valid() bool {
	for _, b := range s {
		if !validByte(b) {
			return false
		}
	}
	if len(s) > 0 && s[len(s)-1] == alphabetLow {
		return false
	}
	return true
}

func MidString(lower, upper OrderString) (OrderString, error) {
	// Reject strings that end with the alphabet's lowest character,
	// since these could not have been generated by this function
	// and may have no solution.
	if (len(lower) > 0 && lower[len(lower)-1] == alphabetLow) ||
		(len(upper) > 0 && upper[len(upper)-1] == alphabetLow) {
		return nil, ErrInvalidArgument
	}

	// // Handle calls with an empty right.
	// if len(lower) != 0 && len(upper) == 0 {
	// 	// Construct a right that is the alphabetHigh extension of left
	// 	upper = []byte{alphabetHigh}
	// 	for i := 0; i < len(lower) && lower[i] < upper[i]; i++ {
	// 		upper = append(upper, alphabetHigh)
	// 	}
	// }

	r1, e1 := MidStringA(lower, upper)
	return r1, e1
}

func MidStringA(prev, next OrderString) (OrderString, error) {
	// Verify that left < right (lexicographically)
	if len(next) > 0 && bytes.Compare(prev, next) >= 0 {
		return nil, fmt.Errorf("left is not less than right: %w", ErrInvalidArgument)
	}

	// Reject slices containing bytes outside our alphabet.
	for _, b := range prev {
		if b < alphabetLow || b > alphabetHigh {
			return nil, ErrInvalidArgument
		}
	}
	for _, b := range next {
		if b < alphabetLow || b > alphabetHigh {
			return nil, ErrInvalidArgument
		}
	}

	p := byte(0)
	n := byte(0)

	var res []byte

	for p == n {
		p = alphabetPred
		if len(prev) > 0 && len(res) < len(prev) {
			p = prev[len(res)]
		}

		n = alphabetSucc
		if len(next) > 0 && len(res) < len(next) {
			n = next[len(res)]
		}

		if p == n {
			res = append(res, p)
		}
	}

	if p == alphabetPred {
		// Left is a prefix of Right
		//
		// While Right's next character is the first character of the alpabet....
		for n == alphabetLow {
			// Append the first character to match.
			res = append(res, alphabetLow)
			// Get Right's next charater.
			if len(res) < len(next) {
				n = next[len(res)]
			} else {
				n = alphabetSucc
			}
		}
		// If Right's next character is the second character of the alphabet...
		if n == alphabetLow+1 {
			// Append the first character of the alphabet and set r to
			// one past the last character of the alphabet.
			res = append(res, alphabetLow)
			n = alphabetSucc
		}
	} else if p+1 == n {
		// Found consecutive byte values.
		res = append(res, p)
		n = alphabetSucc
		for {
			if len(res) >= len(prev) {
				p = alphabetPred
			} else {
				p = prev[len(res)]
			}
			if p != alphabetHigh {
				break
			}
			res = append(res, alphabetHigh)
		}
	}

	res = append(res, n-(n-p)/2)

	return res, nil
}
